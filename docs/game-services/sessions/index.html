<section class="page">
	<div style="left:0">
		<nav>
			<ol>
				<li>
					<a href="/docs">Epic Developer Resources</a>
				</li>
				<li aria-hidden="true"></li>
				<li></li>
				<li aria-hidden="true"></li>
				<li>
					<span aria-label="Sessions Interface">Sessions Interface</span>
				</li>
			</ol>
		</nav>
		<div></div>
	</div>
	<section>
		<div>
			<h1>Sessions Interface</h1>
			<h2>Interface to handle session-based matchmaking</h2>
			<div>
				<div>31 mins to read</div>
			</div>
		</div>
	</section>
	<section>
		<section>
			<p>
				<strong>Epic Online Services</strong>
				(EOS) gives players the ability to host, find, and interact with online gaming sessions through the
				<strong>Sessions Interface</strong>. A session can be short, like filling a certain number of player slots before starting a game, then disbanding after the game ends, or it could be longer, like keeping track of a game that cycles through matches on multiple maps or levels. The Sessions Interface also manages game-specific data that supports the back-end service searching and matchmaking functionality. This document covers some of the definitions and headers for the Sessions Interface. See the
				<a href="/docs/api-ref/interfaces/sessions">Sessions Interface API Reference</a>
				documentation for a complete list.</p>
			
			<!-- -->
			<p>To use the Sessions Interface, acquire an
				<code>EOS_HSessions</code>
				handle through the
				<a href="/docs/game-services/eos-platform-interface">Platform Interface</a>
				function,
				<code>EOS_Platform_GetSessionsInterface</code>. All Sessions Interface functions require this handle as their first parameter. You must ensure that the
				<code>EOS_HPlatform</code>
				handle is ticking for callbacks to trigger when requests are completed. See the
				<a href="/docs/epic-online-services/eossdkc-sharp-getting-started#ticking">EOS SDK in C#</a>
				documentation for more information on ticking.</p>
			<p>Please see the
				<strong>
					<a href="/docs/en-US#matchmaking-security-considerations">security documentation</a>
				</strong>
				for various considerations when using this interface.</p>
			<div>
				<h2 id="active-sessions">Active Sessions</h2>
			</div>
			<p>Active sessions are at the core of everything the Sessions Interface does. An application can have multiple active sessions at the same time, each identified by a unique, local name. For example, there might be a session called "Party" with the local player's friends, keeping them together as they play matches against other teams, and another called "Game" that includes some or all of those friends as well as other players in the match currently in progress. Each session has its own
				<code>EOS_HActiveSession</code>
				handle on each participating player's system. An active session forms on a player's machine whenever that player creates a session, or joins a session found in an online search or through an invitation. Since active sessions exist locally, the local application must destroy them when they are no longer needed. If a host fails to do this, the back-end service server will delay destruction of the session, which can lead to other players falsely discovering sessions in their online searches.</p>
			<p>To get a copy of the high-level information (type
				<code>EOS_ActiveSession_Info</code>), for an active session, including its name, the ID of the local user who created or joined it, its
				<a href="/docs/api-ref/enums/eos-e-online-session-state">current state</a>, a reference to the session details (a const pointer to
				<code>EOS_SessionDetails_Info</code>), and any user-defined data attributes, you must first get its active session handle (type
				<code>EOS_HActiveSession</code>) by calling the local function
				<code>EOS_Sessions_CopyActiveSessionHandle</code>
				with an
				<code>EOS_Sessions_CopyActiveSessionHandleOptions</code>
				initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>Name of the session for which to retrieve a session handle</td>
					</tr>
				</tbody>
			</table>
			<p>With this handle, you can call
				<code>EOS_ActiveSession_CopyInfo</code>. You will also need to initialize and pass in an
				<code>EOS_ActiveSession_CopyInfoOptions</code>
				as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_ACTIVESESSION_COPYINFO_API_LATEST</code>
						</td>
					</tr>
				</tbody>
			</table>
			<p>This function also runs locally and, on success, makes a copy of the session's
				<code>EOS_ActiveSession_Info</code>
				data. You are responsible for releasing the copy with
				<code>EOS_ActiveSession_Info_Release</code>
				when you no longer need it.</p>
			<div>
				<h2 id="session-details">Session Details</h2>
			</div>
			<p>Active sessions that you create locally or discover through searches, invitations, or other users'
				<a href="/docs/epic-account-services/eos-presence-interface">presence</a>
				data store an internal data structure called
				<code>EOS_SessionDetails_Info</code>, which contains basic details about the session:</p>
			<ul>
				<li>
					<p>Session ID</p>
				</li>
				<li>
					<p>Host address</p>
				</li>
				<li>
					<p>Number of open slots in the session</p>
				</li>
			</ul>
			<p>The structure also contains a pointer to another structure,
				<code>EOS_SessionDetails_Settings</code>, which provides more detail about the state of a session, including:</p>
			<ul>
				<li>
					<p>Top-level filtering criteria, called the
						<strong>Bucket ID</strong>, which is specific to your game; often formatted like "GameMode:Region:MapName"</p>
				</li>
				<li>
					<p>Total number of connections allowed on the session</p>
				</li>
				<li>
					<p>Join-in-progress settings</p>
				</li>
				<li>
					<p>Privacy setting</p>
				</li>
			</ul>
			<div>
				<h3 id="accessing-session-details">Accessing Session Details</h3>
			</div>
			<p>If you have an
				<code>EOS_ActiveSession_Info</code>
				data structure, its
				<code>SessionDetails</code>
				variable gives you access to the
				<code>EOS_SessionDetails_Info</code>
				for that session. If not, you can use an
				<code>EOS_HSessionDetails</code>
				handle to call
				<code>EOS_SessionDetails_CopyInfo</code>
				to acquire a copy of the
				<code>EOS_SessionDetails_Info</code>
				data. Call
				<code>EOS_SessionDetails_CopyInfo</code>
				with an
				<code>EOS_SessionDetails_CopyInfoOptions</code>
				structure containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONDETAILS_COPYINFO_API_LATEST</code>
						</td>
					</tr>
				</tbody>
			</table>
			<p>On success, this will return a copy of the session's
				<code>EOS_SessionDetails_Info</code>, which contains the session's ID, the address of the host, and the number of open slots in the session. When you no longer need this information, call
				<code>EOS_SessionDetails_Info_Release</code>
				to free it.</p>
			<div>
				<h2 id="creating-a-session">Creating a Session</h2>
			</div>
			<p>Creating a session is a two-step process.</p>
			<p>First, establish the initial state and settings for the session locally with the
				<code>EOS_Sessions_CreateSessionModification</code>
				function. You'll need to pass in an
				<code>EOS_Sessions_CreateSessionModificationOptions</code>
				structure with the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The name of the session, unique among sessions created by this user</td>
					</tr>
					<tr>
						<td>
							<code>BucketId</code>
						</td>
						<td>The top-level, game-specific filtering information for session searches. This criteria should be set with mostly static, coarse settings, often formatted like "GameMode:Region:MapName".</td>
					</tr>
					<tr>
						<td>
							<code>MaxPlayers</code>
						</td>
						<td>The maximum number of players allowed in the session at any time</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The user ID associated with the session</td>
					</tr>
					<tr>
						<td>
							<code>bPresenceEnabled</code>
						</td>
						<td>Whether or not this session should be the one associated with the local user's presence information (see the
							<a href="/docs/epic-account-services/eos-presence-interface">Presence Interface</a>
							for more details)</td>
					</tr>
					<tr>
						<td>
							<code>SessionId</code>
						</td>
						<td>(OPTIONAL) Set this value to override the unique ID that would regularly be assigned to this session on creation. It is possible to use this to set values that correlate with other developer identifiers. In this way, it is not necessary to add additional attributes to the session and require the session to advertise publicly in order to find “private sessions”. This value must be globally unique within the application ecosystem. Failure to do so will result in 'EOS_Sessions_SessionAlreadyExists' errors.</td>
					</tr>
					<tr>
						<td>
							<code>bSanctionsEnabled</code>
						</td>
						<td>Whether or not this session should enforce preventing sanctioned users from joining this session. It will prevent calls to
							<code>Join</code>
							and
							<code>RegisterPlayers</code>
							from succeeding with those users.  See the
							<a href="/docs/game-services/sanctions-interface">Sanctions Interface</a>
							documentation for details.</td>
					</tr>
				</tbody>
			</table>
			<p>If the
				<code>EOS_Sessions_CreateSessionModification</code>
				call succeeds, it will return
				<code>EOS_Success</code>
				and the default
				<code>EOS_HSessionModification</code>
				you provided will contain a valid handle.</p>
			<p>Second, continue to modify the session's initial setup (see the section on
				<a href="/docs/en-US#modifying-a-session">modifying a session</a>
				until you have made all the modifications you need. You can then complete the creation process by calling
				<code>EOS_Sessions_UpdateSession</code>
				with an
				<code>EOS_Sessions_UpdateSessionOptions</code>
				structure initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_UPDATESESSION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionModificationHandle</code>
						</td>
						<td>The handle (<code>EOS_HSessionModification</code>) for the session you want to create or update</td>
					</tr>
				</tbody>
			</table>
			<p>
				<code>EOS_Sessions_UpdateSession</code>
				is asynchronous, and will call your delegate (of type
				<code>EOS_Sessions_OnUpdateSessionCallback</code>) upon completion with an
				<code>EOS_Sessions_UpdateSessionCallbackInfo</code>
				data structure. On success, the local name that you provided will be paired with a searchable, unique ID string from the server.</p>
			<div>
				<h2 id="player-details">Player Details</h2>
			</div>
			<p>You can retrieve the following player data from the active session:</p>
			<ul>
				<li>The total number of registered players.</li>
				<li>The product user ID (PUID) of each registered player.</li>
			</ul>
			<div>
				<h3 id="accessing-the-total-number-of-registered-players">Accessing the Total Number of Registered Players</h3>
			</div>
			<p>You can call
				<code>EOS_ActiveSession_GetRegisteredPlayerCount</code>
				to get the total number of registered players associated with the active session. To do this, call
				<code>EOS_ActiveSession_GetRegisteredPlayerCount</code>
				with an
				<code>ActiveSessionGetRegisteredPlayerCountOptions</code>
				structure that contains the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST</code>
						</td>
					</tr>
				</tbody>
			</table>
			<div>
				<h3 id="accessing-the-product-user-id-of-each-registered-player">Accessing the Product User ID of Each Registered Player</h3>
			</div>
			<p>You can iterate through the registered players for the active session to get the product user ID (PUID) of each registered player. To do this, call
				<code>EOS_ActiveSession_GetRegisteredPlayerByIndex</code>
				with an
				<code>ActiveSessionGetRegisteredPlayerByIndexOptions</code>
				structure that contains the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>PlayerIndex</code>
						</td>
						<td>Index of the registered player to retrieve.</td>
					</tr>
				</tbody>
			</table>
			<p>On success, this returns the product user ID (PUID) of the player at the specified index for the active session.</p>
			<div>
				<h2 id="modifying-a-session">Modifying a Session</h2>
			</div>
			<p>To modify an existing session, first call
				<code>EOS_Sessions_UpdateSessionModification</code>
				with a pointer to a default
				<code>EOS_HSessionModification</code>
				object and an
				<code>EOS_Sessions_UpdateSessionModificationOptions</code>
				structure initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The name of the session you want to modify</td>
					</tr>
				</tbody>
			</table>
			<p>If this call succeeds, it will return
				<code>EOS_Success</code>, the modification will be applied to the local session, and the
				<code>EOS_HSessionModification</code>
				object you provided will now be a valid handle. If you are the session owner, you can use that handle to apply the local changes you've made to the back-end service's version of the session, by calling
				<code>EOS_Sessions_UpdateSession</code>. This function works for both new sessions (those that have not yet been created on the server) and pre-existing ones. The following functions modify different aspects of the session:</p>
			<table>
				<thead>
					<tr>
						<td>Function</td>
						<td>Effect</td>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>EOS_SessionModification_SetHostAddress</code>
						</td>
						<td>This changes the string containing the data required to reach the server. The host address does not have to be an IP address; a socket ID, URL, or other attribution can work.</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SessionModification_SetBucketId</code>
						</td>
						<td>The Bucket ID is the main search criteria, containing game-specific information that is required in all searches. For example, a format like "GameMode:Region:MapName" could be used to form the Bucket ID.</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SessionModification_SetMaxPlayers</code>
						</td>
						<td>Use this to set the maximum number of players allowed in the session.</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SessionModification_SetJoinInProgressAllowed</code>
						</td>
						<td>You can permit or forbid players to join games that have already begun (see the section on
							<a href="/docs/en-US#starting-and-ending-play">starting and ending play</a>
							for more details) with this function.</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SessionModification_SetPermissionLevel</code>
						</td>
						<td>This function can change the session's privacy settings to any of the following:<br>
							<ul>
								<li>
									<code>EOS_OSPF_PublicAdvertised</code>: The session will be visible to all players and will show up in searches.</li>
								<li>
									<code>EOS_OSPF_JoinViaPresence</code>: Only players with access to the creating user's presence information, which contains the session ID, can find this session.</li>
								<li>
									<code>EOS_OSPF_InviteOnly</code>: The session is available only to invited players.</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SessionModification_AddAttribute</code>
						</td>
						<td>Adds a custom attribute (type
							<code>EOS_SessionDetails_AttributeData</code>) to the session. See the
							<a href="/docs/en-US#custom-attributes">Custom Attributes</a>
							section for more information.</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SessionModification_RemoveAttribute</code>
						</td>
						<td>Removes a custom attribute from the session. See the
							<a href="/docs/en-US#custom-attributes">Custom Attributes</a>
							section for more information.</td>
					</tr>
				</tbody>
			</table>
			<p>After modifying the session locally, you can update the session on the back-end service if you are the session owner. To do this, call
				<code>EOS_Sessions_UpdateSession</code>
				with an
				<code>EOS_Sessions_UpdateSessionOptions</code>
				containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_UPDATESESSION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionModificationHandle</code>
						</td>
						<td>The handle (<code>EOS_HSessionModification</code>) for the session you want the server to create or update</td>
					</tr>
				</tbody>
			</table>
			<p>This operation will call your callback function, of type
				<code>EOS_Sessions_OnUpdateSessionCallback</code>, with an
				<code>EOS_Sessions_UpdateSessionCallbackInfo</code>
				data structure upon completion.</p>
			<div role="alert">
				<div></div>
				<div>
					<p>EOS supports modifying sessions during play. Even a session that has ended but has not been destroyed can receive updates and start again. A common use case for this behavior is a game that runs a match on one map or level, then cycles through a list to find the next one, and starts a fresh match there, with different players joining and leaving between (or even during) matches.</p>
				</div>
			</div>
			<div>
				<h3 id="custom-attributes">Custom Attributes</h3>
			</div>
			<p>Sessions can contain user-defined data, called
				<strong>attributes</strong>. Each attribute has a name, which acts as a string key, a value, an enumerated variable identifying the value's type, and a visibility setting. The following variable types are currently supported:</p>
			<table>
				<thead>
					<tr>
						<th>
							<code>EOS_ESessionAttributeType</code>
						</th>
						<th>Value Type</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>EOS_SAT_BOOLEAN</code>
						</td>
						<td>
							<code>EOS_Bool</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SAT_INT64</code>
						</td>
						<td>
							<code>int64_t</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SAT_DOUBLE</code>
						</td>
						<td>
							<code>double</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SAT_STRING</code>
						</td>
						<td>
							<code>const char*</code>
							(null-terminated UTF8 string)</td>
					</tr>
				</tbody>
			</table>
			<p>The following visibility types are available:</p>
			<table>
				<thead>
					<tr>
						<th>
							<code>EOS_ESessionAttributeAdvertisementType</code>
						</th>
						<th>Visbility</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>EOS_SAAT_DontAdvertise</code>
						</td>
						<td>Not visible to other users</td>
					</tr>
					<tr>
						<td>
							<code>EOS_SAAT_Advertise</code>
						</td>
						<td>Visible to other users</td>
					</tr>
				</tbody>
			</table>
			<div>
				<h4 id="accessing-an-attribute">Accessing an Attribute</h4>
			</div>
			<p>You can find out how many attributes a session has by calling
				<code>EOS_SessionDetails_GetSessionAttributeCount</code>
				with a valid
				<code>EOS_HSessionDetails</code>
				handle and an
				<code>EOS_SessionDetails_CopySessionAttributeByIndexOptions</code>
				containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>ApiVersion</td>
						<td>
							<code>EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST</code>
						</td>
					</tr>
				</tbody>
			</table>
			<p>To get a copy of an attribute, call
				<code>EOS_SessionDetails_CopySessionAttributeByIndex</code>
				with a valid
				<code>EOS_HSessionDetails</code>
				handle and an
				<code>EOS_SessionDetails_CopySessionAttributeByIndexOptions</code>
				initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>ApiVersion</td>
						<td>
							<code>EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>AttrIndex</code>
						</td>
						<td>The index of the attribute to copy</td>
					</tr>
				</tbody>
			</table>
			<p>On success, this will return
				<code>EOS_Success</code>
				and your output parameter will contain a copy of the
				<code>EOS_SessionDetails_Attribute</code>
				structure corresponding to the attribute index you requested. This structure contains the Attribute's value and type in an
				<code>EOS_Sessions_AttributeData</code>
				data structure, and its visibility in an
				<code>EOS_ESessionAttributeAdvertisementType</code>
				enumerated value. When you no longer need this data, release it with
				<code>EOS_SessionDetails_Attribute_Release</code>.</p>
			<div>
				<h4 id="adding-an-attribute">Adding an Attribute</h4>
			</div>
			<p>You can set up an attribute that you would like to add or modify by filling an
				<code>EOS_Sessions_AttributeData</code>
				data structure with the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>Key</code>
						</td>
						<td>The name of the attribute</td>
					</tr>
					<tr>
						<td>
							<code>Value</code>
						</td>
						<td>The attribute's value, or, in the case of strings, a pointer to the string</td>
					</tr>
					<tr>
						<td>
							<code>ValueType</code>
						</td>
						<td>An
							<code>EOS_ESessionAttributeType</code>
							that describes
							<code>Value</code>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Once you have this data ready, call
				<code>EOS_SessionModification_AddAttribute</code>
				to add the attribute. You must provide your
				<code>EOS_HSessionModification</code>
				handle and an
				<code>EOS_SessionModification_AddAttributeOptions</code>, intialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionAttribute</code>
						</td>
						<td>A const pointer to an
							<code>EOS_Sessions_AttributeData</code>
							containing the modification you want to make</td>
					</tr>
					<tr>
						<td>
							<code>AdvertisementType</code>
						</td>
						<td>An
							<code>EOS_ESessionAttributeAdvertisementType</code>
							indicating whether or not this attribute should be publicly visible</td>
					</tr>
				</tbody>
			</table>
			<p>You can store up to
				<code>EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTES</code>
				(currently 64) in a session, and each attribute's name can be up to
				<code>EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTE_LENGTH</code>
				(currently 32) characters long.</p>
			<div>
				<p>This function only sets up the attribute that you want to add or update. It does not actually add or update the attribute, or interact with the session in any way. You will still need to call
					<code>EOS_Sessions_UpdateSession</code>
					as described at the top of this
					<a href="/docs/en-US#modifying-a-session">section</a>.</p>
			</div>
			<div>
				<h4 id="removing-an-attribute">Removing an Attribute</h4>
			</div>
			<p>To remove an attribute, call
				<code>EOS_SessionModification_RemoveAttribute</code>
				with the
				<code>EOS_HSessionModification</code>
				handle for your session, and an
				<code>EOS_SessionModification_RemoveAttributeOptions</code>
				structure containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>Key</code>
						</td>
						<td>The name (key) of the attribute you want to remove</td>
					</tr>
				</tbody>
			</table>
			<div>
				<p>This function only establishes that you want to remove a certain attribute. It does not actually remove the attribute, or interact with the session in any way. You will still need to call
					<code>EOS_Sessions_UpdateSession</code>
					as described at the top of this
					<a href="/docs/en-US#modifying-a-session">section</a>.</p>
			</div>
			<div>
				<h2 id="inviting-players-to-a-session">Inviting Players to a Session</h2>
			</div>
			<p>To invite another player to join an active session, a
				<a href="/docs/en-US#registering-a-player">registered</a>
				member of the session can call
				<code>EOS_Sessions_SendInvite</code>
				with an
				<code>EOS_Sessions_SendInviteOptions</code>
				structure containing the following data:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_SENDINVITE_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The name of the session to which the player is invited</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The local user sending the invitation</td>
					</tr>
					<tr>
						<td>
							<code>TargetUserId</code>
						</td>
						<td>The remote user being invited</td>
					</tr>
				</tbody>
			</table>
			<p>Once the server has processed the invitation request, your callback, of type
				<code>EOS_Sessions_OnSendInviteCallback</code>, will run with an
				<code>EOS_Sessions_SendInviteCallbackInfo</code>
				structure containing a result code. This result indicates success if there was no error in the process of sending the invitation; success does not mean that the remote user has accepted, or even seen, the invitation.</p>
			<div>
				<p>For invite functionality with the Epic Games Launcher, be sure to map your deployments to your
					<a href="/docs/epic-games-store/services/launcher-invites">artifacts</a>
					as well.</p>
			</div>
			<p>(#GettingHSessionFromInviteID) The remote user will receive notification of the invitation when it arrives, and the payload will provide the user ID that has been invited as well as the ID of the invitation itself. Upon receipt, use
				<code>EOS_Sessions_CopySessionHandleByInviteId</code>
				to retrieve the
				<code>EOS_HSessionDetails</code>
				handle from the invitation. You can use this handle to gain access to the
				<a href="/docs/en-US#session-details">session details</a>
				data for the associated session, or to accept or reject the invitation. Once you are finished with the handle, call
				<code>EOS_SessionDetails_Release</code>
				to release it.</p>
			<p>In order to receive this notification, you must register a callback with
				<code>EOS_Sessions_AddNotifySessionInviteReceived</code>. You only need to do this once, typically at startup, after which your callback will run as each invitation is received. When you no longer need notification, call
				<code>EOS_Sessions_RemoveNotifySessionInviteReceived</code>
				to remove your callback.</p>
			<div>
				<h3 id="accepting-an-invitation">Accepting an Invitation</h3>
			</div>
			<p>The Sessions Interface does not feature a dedicated function for accepting an invitation. You can
				<a href="/docs/en-US#joining-a-session">join</a>
				the session using the standard method with the
				<code>EOS_HSessionDetails</code>
				handle that you retrieved from the invitation. To request a list of all pending invitations, call
				<code>EOS_Sessions_QueryInvites</code>
				with an
				<code>EOS_Sessions_QueryInvitesOptions</code>
				data structure initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_QUERYINVITES_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The local user whose invitations are being requested</td>
					</tr>
				</tbody>
			</table>
			<p>This operation is asynchronous. When it finishes, it will call your callback function, of type
				<code>EOS_Sessions_OnQueryInvitesCallback</code>, with an
				<code>EOS_Sessions_QueryInvitesCallbackInfo</code>
				data structure. On success, EOS will have all of the user's pending invitations cached locally. You can use
				<code>EOS_Sessions_GetInviteCount</code>
				to determine the number of invitations in the cache. Pass in an
				<code>EOS_Sessions_GetInviteCountOptions</code>
				structure with the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_GETINVITECOUNT_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The local user who has cached invitations</td>
					</tr>
				</tbody>
			</table>
			<p>This function runs locally and will return a
				<code>uint32_t</code>
				that represents the number of invitations currently in the cache. To get the ID of any cached invitation, call
				<code>EOS_Sessions_GetInviteIdByIndex</code>
				with an
				<code>EOS_Sessions_GetInviteIdByIndexOptions</code>
				containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The local user who has cached invitations</td>
					</tr>
					<tr>
						<td>
							<code>Index</code>
						</td>
						<td>The cache index of the invitation whose ID we want to retrieve</td>
					</tr>
				</tbody>
			</table>
			<p>If
				<code>EOS_Sessions_GetInviteIdByIndex</code>
				returns
				<code>EOS_Success</code>, the output parameters you passed to it contain the invitation's ID as a null-terminated character string and the length of that string.</p>
			<div>
				<p>The max length of an invitation's ID string is
					<code>EOS_SESSIONS_INVITEID_MAX_LENGTH</code>
					(currently 64).</p>
			</div>
			<p>As described
				<a href="/docs/en-US#inviting-players-to-a-session">above</a>, the
				<code>EOS_Sessions_CopySessionHandleByInviteId</code>
				function will provide an
				<code>EOS_HSession</code>
				handle which gives you access to the
				<a href="/docs/en-US#session-details">session details</a>
				data for the associated session. You can then choose to accept the invitation by
				<a href="/docs/en-US#joining-a-session">joining</a>
				the session, ignore the invitation, or
				<a href="/docs/en-US#rejecting-an-invitation">reject</a>
				it. Once you are finished with the
				<code>EOS_HSession</code>
				handle, call
				<code>EOS_SessionDetails_Release</code>
				to release it.</p>
			<div>
				<h3 id="rejecting-an-invitation">Rejecting an Invitation</h3>
			</div>
			<p>To reject an invitation, call
				<code>EOS_Sessions_RejectInvite</code>
				with an
				<code>EOS_Sessions_RejectInviteOptions</code>
				initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_REJECTINVITE</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The local user rejecting the invitation</td>
					</tr>
					<tr>
						<td>
							<code>InviteId</code>
						</td>
						<td>The ID of the invitation</td>
					</tr>
				</tbody>
			</table>
			<p>Upon completion, you will receive a call to your
				<code>EOS_Sessions_OnRejectInviteCallback</code>
				callback function with an
				<code>EOS_Sessions_RejectInviteCallbackInfo</code>
				data structure indicating success or failure. Successfully rejecting an invitation permanently deletes it from the system.</p>
			<div>
				<h2 id="discovering-a-remote-session">Discovering a Remote Session</h2>
			</div>
			<p>To find a remote session, you need to configure a search, execute that search, then examine the results.</p>
			<div>
				<h3 id="configuring-a-search">Configuring a Search</h3>
			</div>
			<p>To begin a search, first call
				<code>EOS_Sessions_CreateSessionSearch</code>
				to create a search handle. Pass in an
				<code>EOS_Sessions_CreateSessionSearchOptions</code>
				structure, initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>MaxSearchResults</code>
						</td>
						<td>Maximum number of search results to return</td>
					</tr>
				</tbody>
			</table>
			<p>This function runs locally and will fill out the default search handle (of type
				<code>EOS_HSessionSearch</code>) on success. The next step is to configure the handle to perform a specific search with the criteria you require. EOS provides three methods to search for sessions:</p>
			<ul>
				<li>
					<p>
						<strong>Session ID:</strong>
						Finds a single session with a known ID</p>
				</li>
				<li>
					<p>
						<strong>User ID:</strong>
						Finds all sessions involving a known user — presently limited to local users</p>
				</li>
				<li>
					<p>
						<strong>Attribute Data:</strong>
						Finds all sessions that match some user-defined filtering criteria</p>
				</li>
			</ul>
			
			<!-- -->
			<div>
				<h4 id="configuring-for-session-id">Configuring for Session ID</h4>
			</div>
			<p>If you want a specific session and know its server-side ID, call
				<code>EOS_SessionSearch_SetSessionId</code>
				with your search handle and an
				<code>EOS_SessionSearch_SetSessionIdOptions</code>
				initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionId</code>
						</td>
						<td>The ID of the session you want to find</td>
					</tr>
				</tbody>
			</table>
			<p>This is the only step required to configure a session ID search. Unlike the other search methods, this will never return more than one result.</p>
			<div>
				<p>Only sessions marked as
					<code>EOS_OSPF_PublicAdvertised</code>
					or
					<code>EOS_OSPF_JoinViaPresence</code>
					can be found this way.</p>
			</div>
			<div role="alert">
				<div></div>
				<div>
					<p>Because sessions that you configure in this way are publicly visible, applications outside of the EOS ecosystem could discover them. These applications could use session data to retrieve the IP address of the server or P2P host, and potentially attempt to cause disruption.</p>
				</div>
			</div>
			<div>
				<h4 id="configuring-for-user-id">Configuring for User ID</h4>
			</div>
			<p>To find all sessions that involve a known user, call
				<code>EOS_SessionSearch_SetTargetUserId</code>
				with your search handle and an
				<code>EOS_SessionSearch_SetTargetUserIdOptions</code>
				containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONSEARCH_SETTARGETUSERID_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>TargetUserId</code>
						</td>
						<td>The user ID to find within sessions</td>
					</tr>
				</tbody>
			</table>
			<p>This is the only step required to configure a user ID search. Must be a local, logged-in user.</p>
			<div>
				<p>The application can only find locally authenticated users or remote users that are registered in public sessions.</p>
			</div>
			<div role="alert">
				<div></div>
				<div>
					<p>Registered users of publicly visible sessions (sessions configured with
						<code>EOS_OSPF_PublicAdvertised</code>
						or
						<code>EOS_OSPF_JoinViaPresence</code>) are themselves publicly visible, including applications outside of the EOS ecosystem. These applications could use session data to discover the IP address of the server or P2P host, and potentially attempt to cause disruption.</p>
				</div>
			</div>
			<div>
				<h4 id="configuring-for-attribute-data">Configuring for Attribute Data</h4>
			</div>
			<p>The most robust way to find sessions is to search based on a set of search parameters, which act as filters. Some parameters could be exposed to the user, such as enabling the user to select a certain game type or map, while others might be hidden, such as using the player's estimated skill level to find matches with appropriate opponents. This search method can take multiple parameters, and will only find sessions that pass through all of them. To set up a search parameter, call
				<code>EOS_SessionSearch_SetParameter</code>
				with your search handle and an
				<code>EOS_SessionSearch_SetParameterOptions</code>
				containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>Parameter</code>
						</td>
						<td>A key and a value to compare to an
							<a href="/docs/en-US#custom-attributes">attribute</a>
							associated with the session</td>
					</tr>
					<tr>
						<td>
							<code>ComparisonOp</code>
						</td>
						<td>The type of comparison to make</td>
					</tr>
				</tbody>
			</table>
			<p>This function can be called multiple times to set up multiple filters, all of which must be satisfied for a session to show up in the search results. The following table lists the types of comparisons you can use, what value types they work on, and what condition must be met in order to pass:</p>
			<table>
				<thead>
					<tr>
						<th>
							<code>ComparisonOp</code>
						</th>
						<th>Acceptable Value Types</th>
						<th>Success Condition</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>EOS_CO_EQUAL</code>
						</td>
						<td>All</td>
						<td>Attribute is equal to the search value</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_NOTEQUAL</code>
						</td>
						<td>All</td>
						<td>Attribute is not equal to the search value</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_GREATERTHAN</code>
						</td>
						<td>Numerical Types</td>
						<td>Attribute is greater than the search value</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_GREATERTHANOREQUAL</code>
						</td>
						<td>Numerical Types</td>
						<td>Attribute is greater than or equal to the search value</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_LESSTHAN</code>
						</td>
						<td>Numerical Types</td>
						<td>Attribute is less than the search value</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_LESSTHANOREQUAL</code>
						</td>
						<td>Numerical Types</td>
						<td>Attribute is less than or equal to the search value</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_DISTANCE</code>
						</td>
						<td>Numerical Types</td>
						<td>Not a filter; attributes are sorted based on how close they are to to the search value, or
							<code>Abs(AttributeValue - SearchValue)</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_ANYOF</code>
						</td>
						<td>Strings</td>
						<td>Attribute matches any member of a semicolon-delimited list (for example, "This;OrThis;MaybeThis")</td>
					</tr>
					<tr>
						<td>
							<code>EOS_CO_NOTANYOF</code>
						</td>
						<td>Strings</td>
						<td>Attribute does not match any member of a semicolon-delimited list (for example "NotThis;OrThisEither")</td>
					</tr>
				</tbody>
			</table>
			<div>
				<h3 id="executing-a-search">Executing a Search</h3>
			</div>
			<p>To execute the search, call
				<code>EOS_SessionSearch_Find</code>
				with your search handle and an
				<a href="/docs/api-ref/structs/eos-session-search-find-options">
					<code>EOS_SessionSearch_FindOptions</code>
				</a>
				structure initialized as follows:</p>
			<p>This is an asynchronous operation. When it finishes, your callback function, of type
				<code>EOS_SessionSearch_OnFindCallback</code>, will receive an
				<code>EOS_SessionSearch_FindCallbackInfo</code>
				structure notifying you of the success or failure of the search. Following successful completion, you can get copies of the search results from the EOS cache.</p>
			<div>
				<p>EOS supports running multiple
					<code>EOS_SessionSearch_Find</code>
					operations in parallel.</p>
			</div>
			<p>
				<strong>Tip</strong>: You can search by the attribute
				<code>EOS_SESSIONS_SEARCH_MINSLOTSAVAILABLE</code>
				to find sessions that are not full (still have slots available). Set the value type to
				<code>int64_t</code>, and use the
				<code>EOS_CO_GREATERTHANOREQUAL</code>
				comparison operator to set the value to at least
				<code>1</code>. This excludes full sessions from the results.</p>
			<div>
				<h3 id="examining-search-results">Examining Search Results</h3>
			</div>
			<p>
				<code>EOS_SessionSearch_GetSearchResultCount</code>
				for a given
				<code>EOS_HSessionSearch</code>
				handle and
				<code>EOS_SessionSearch_CopySearchResultByIndex</code>
				will return the session details one by one through individual
				<code>EOS_HSessionDetails</code>
				handles.</p>
			<p>After completing a successful search, use
				<code>EOS_SessionSearch_GetSearchResultCount</code>
				with your search handle to get the number of results that the search returned. You can then call
				<code>EOS_SessionSearch_CopySearchResultByIndex</code>
				to get a copy of the
				<code>EOS_HSessionDetails</code>
				handle associated with the
				<a href="/docs/en-US#active-sessions">active session</a>
				at that index. This handle provides access to
				<a href="/docs/en-US#session-details">session details</a>
				data, which you can use to display information about the session to the local user or determine whether or not to
				<a href="/docs/en-US#joining-a-session">join</a>
				the session using your own game logic. You must release the
				<code>EOS_HSessionDetails</code>
				handle with
				<code>EOS_SessionDetails_Release</code>
				when you no longer need it.</p>
			<div>
				<h2 id="joining-a-session">Joining a Session</h2>
			</div>
			<p>You can join an existing session if you have a valid
				<code>EOS_HSessionDetails</code>
				handle to it by calling
				<code>EOS_Sessions_JoinSession</code>
				and providing an
				<code>EOS_Sessions_JoinSessionOptions</code>
				structure with the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_JOINSESSION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The unique name that the local system will use to refer to the session</td>
					</tr>
					<tr>
						<td>
							<code>SessionHandle</code>
						</td>
						<td>The
							<code>EOS_HSessionDetails</code>
							handle for the session you want to join</td>
					</tr>
					<tr>
						<td>
							<code>LocalUserId</code>
						</td>
						<td>The local user joining the session</td>
					</tr>
					<tr>
						<td>
							<code>bPresenceEnabled</code>
						</td>
						<td>Whether or not this session should be the one associated with the local user's presence information (see the
							<a href="/docs/epic-account-services/eos-presence-interface">Presence Interface</a>
							for more details)</td>
					</tr>
				</tbody>
			</table>
			<p>When the operation finishes, your callback function, of type
				<code>EOS_Sessions_OnJoinSessionCallback</code>, will receive an
				<code>EOS_Sessions_JoinSessionCallbackInfo</code>
				indicating success or failure. If the operation succeeds, EOS will create an active session on the joining client's system. As this new session is locally-owned, the joining user is responsible for
				<a href="/docs/en-US#destroying-a-session">destroying</a>
				it once it is no longer needed.</p>
			<div>
				<h3 id="registering-a-player">Registering a Player</h3>
			</div>
			<p>When a player joins the session, the session owner is responsible for registering the player with the session. This keeps the back-end service aware of the number of players so that it may stop advertising the session publicly when it is full. EOS accepts registration of multiple players at once through the
				<code>EOS_Sessions_RegisterPlayers</code>
				function. Call this function from the owning client with an
				<code>EOS_Sessions_RegisterPlayersOptions</code>
				structure containing the following data:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_REGISTERPLAYERS_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The local name of the session</td>
					</tr>
					<tr>
						<td>
							<code>PlayersToRegister</code>
						</td>
						<td>An array of IDs for the joining players</td>
					</tr>
					<tr>
						<td>
							<code>PlayersToRegisterCount</code>
						</td>
						<td>The number of elements in
							<code>PlayersToRegister</code>
						</td>
					</tr>
				</tbody>
			</table>
			<p>On completion, your callback of type
				<code>EOS_Sessions_OnRegisterPlayersCallback</code>
				will run with an
				<code>EOS_Sessions_RegisterPlayersCallbackInfo</code>
				parameter that contains the following data:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ResultCode</code>
						</td>
						<td>Result code indicating success or failure</td>
					</tr>
					<tr>
						<td>
							<code>Registered Players</code>
						</td>
						<td>A list of players successfully registered</td>
					</tr>
					<tr>
						<td>
							<code>Registered Players Count</code>
						</td>
						<td>The number of registered players</td>
					</tr>
					<tr>
						<td>
							<code>Sanctioned Players</code>
						</td>
						<td>A list of players that were not registered due to sanctions</td>
					</tr>
					<tr>
						<td>
							<code>Sanctioned Players Count</code>
						</td>
						<td>The number of players not registered due to sanctions</td>
					</tr>
				</tbody>
			</table>
			<p>If the call succeeds, the newly-registered players will receive access to some session management functionality, such as the ability to invite other players to the session. Note that no errors are returned when one or more sanctioned players are denied registration;
				<em>the
					<code>SanctionedPlayers</code>
					list must be checked manually</em>. See
				<a href="/docs/en-US#enforcing-sanctions">Enforcing Sanctions</a>
				for more details. EOS does not provide notification when a player joins a session, so you must notify the owner when you join, or provide the owner with a way to detect when a player has successfully joined the session.</p>
			<p>After a user registers with a publicly visible session (a session configured with
				<code>EOS_OSPF_PublicAdvertised</code>
				or
				<code>EOS_OSPF_JoinViaPresence</code>), others can find the session with
				<code>EOS_SessionSearch_SetTargetUserId</code>.</p>
			<div role="alert">
				<div></div>
				<div>
					<p>This information is publicly visible, including to applications outside of the EOS ecosystem. These applications could use session data to discover the IP address of the server or P2P host, and potentially attempt to cause disruption.</p>
				</div>
			</div>
			<div>
				<h2 id="leaving-a-session">Leaving a Session</h2>
			</div>
			<p>The Sessions Interface does not feature a dedicated function for leaving a session. To leave a session,
				<a href="/docs/en-US#destroying-a-session">destroy</a>
				your local session through the standard method, using its local name.</p>
			<div>
				<h3 id="unregistering-a-player">Unregistering a Player</h3>
			</div>
			<p>When a player leaves the session, the session's owner is responsible for unregistering the player. This enables the server to free up player slots so that future players can join. EOS accepts unregistration of multiple players at once through the
				<code>EOS_Sessions_UnregisterPlayers</code>
				function. Call this function from the owning client with an
				<code>EOS_Sessions_UnregisterPlayersOptions</code>
				structure containing the following data:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The local name of the session</td>
					</tr>
					<tr>
						<td>
							<code>PlayersToUnregister</code>
						</td>
						<td>An array of IDs for the departing players</td>
					</tr>
					<tr>
						<td>
							<code>PlayersToUnregisterCount</code>
						</td>
						<td>The number of elements in
							<code>PlayersToUnregister</code>
						</td>
					</tr>
				</tbody>
			</table>
			<p>On completion, your callback of type
				<code>EOS_Sessions_OnUnregisterPlayersCallback</code>
				will run with an
				<code>EOS_Sessions_UnregisterPlayersCallbackInfo</code>
				parameter that indicates success or failure. If the call succeeds, the back-end service will revoke the session management access that those players received when they were originally registered. For example, players who are not registered with the session cannot invite others to join it. EOS does not provide notification of a player leaving a session, so you must notify the owner when you leave a session, or provide the owner with a way to detect that a player has left the game or disconnected.</p>
			<div>
				<p>Host migration is not supported for sessions. If the owner of the session leaves or they lose their connection to the network, the session is orphaned, and no one else can manage the session on the back-end.</p>
			</div>
			
			<!-- -->
			<div>
				<h2 id="starting-and-ending-play">Starting and Ending Play</h2>
			</div>
			<p>A player can declare that a match has started or ended for a local active session. If that session maps to a session on the back-end service that the local player owns, the back-end version will also start or end play. While playing, the back-end service will automatically reject attempts to join a session if that session has
				<strong>Join in Progress</strong>
				disabled (see the section on
				<a href="/docs/en-US#modifying-a-session">Modifying a Session</a>
				for more information). Although starting a session typically implies that a match has begun, the specific usage of this functionality is up to the game's developers.</p>
			<p>To start play, call
				<code>EOS_Sessions_StartSession</code>
				with an
				<code>EOS_Sessions_StartSessionOptions</code>
				initialized as follows:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_STARTSESSION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The local name of the session</td>
					</tr>
				</tbody>
			</table>
			<p>When the operation completes, your callback, of type
				<code>EOS_Sessions_OnStartSessionCallback</code>, will run with an
				<code>EOS_Sessions_StartSessionCallbackInfo</code>
				data structure indicating success or failure. If the operation succeeds, the session is considered "in progress" until you end play by calling
				<code>EOS_Sessions_EndSession</code>
				with an
				<code>EOS_Sessions_EndSessionOptions</code>
				containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_ENDSESSION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The local name of the session</td>
					</tr>
				</tbody>
			</table>
			<p>Upon completion, your
				<code>EOS_Sessions_OnEndSessionCallback</code>
				function will receive a call with an
				<code>EOS_Sessions_EndSessionCallbackInfo</code>
				data structure indicating success or failure. On success, the session is no longer considered "in progress" and will once again permit players to join. Ending a session does not remove players or destroy the session; it effectively returns to its pre-start state and remains usable, including the ability to start play again. If you intend to destroy the session, you do not need to call
				<code>EOS_Sessions_EndSession</code>
				first.</p>
			<div>
				<h2 id="destroying-a-session">Destroying a Session</h2>
			</div>
			<p>When you no longer need a session, you must destroy it using
				<code>EOS_Sessions_DestroySession</code>. Call this function with an
				<code>EOS_Sessions_DestroySessionOptions</code>
				data structure containing the following information:</p>
			<table>
				<thead>
					<tr>
						<th>Property</th>
						<th>Value</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>ApiVersion</code>
						</td>
						<td>
							<code>EOS_SESSIONS_DESTROYSESSION_API_LATEST</code>
						</td>
					</tr>
					<tr>
						<td>
							<code>SessionName</code>
						</td>
						<td>The name of the session to destroy</td>
					</tr>
				</tbody>
			</table>
			<p>When the destruction operation completes, you will receive a callback of type
				<code>EOS_Sessions_OnDestroySessionCallback</code>
				with an
				<code>EOS_Sessions_DestroySessionCallbackInfo</code>
				data structure. Upon success, the session will cease to exist and its name will be available for reuse. However, due to the asynchronous nature of this system, it is possible for a player to make a request after you have called
				<code>EOS_Sessions_DestroySession</code>
				but before the back-end service has destroyed the session. In this case, you may receive requests to join the session after having started the destruction operation. It is important to reject these players, or shut down the network to prevent them from joining the defunct session.</p>
			<div>
				<h2 id="mirroring-session-management-on-remote-clients">Mirroring Session Management on Remote Clients</h2>
			</div>
			<p>Through the Sessions Interface, the session owner (the user who created the session) can manage the session's state as it exists on the back-end service. The life cycle of a session starts with its creation and ends with its destruction. Between those two events, the Sessions Interface can modify the session, change its privacy settings, send invitations, register and unregister players as they join and leave, and start, play, and end matches. A session's life cycle is not rigid; for example, sessions can modify their data at any time, and can start and end multiple matches.</p>
			<p>In general, only the owner of the session can make modifications to session data on the back-end service. However, remote clients who
				<a href="/docs/en-US#joining-a-session">join</a>
				a session will have their own local view of the session, and this view does not automatically receive data updates about the back-end version. It is not required, but can be beneficial for remote clients to keep their local view in sync with the back-end session by mirroring the following function calls:</p>
			<ul>
				<li>
					<p>
						<code>EOS_Sessions_StartSession</code>
					</p>
				</li>
				<li>
					<p>
						<code>EOS_Sessions_EndSession</code>
					</p>
				</li>
				<li>
					<p>
						<code>EOS_Sessions_RegisterPlayers</code>
					</p>
				</li>
				<li>
					<p>
						<code>EOS_Sessions_UnregisterPlayers</code>
					</p>
				</li>
			</ul>
			<p>These functions will modify the local state of the session on remote (non-owner) clients without affecting the back-end service's version.</p>
			<div>
				<h2 id="enforcing-sanctions">Enforcing Sanctions</h2>
			</div>
			<p>If you are using EOS Sanctions, then you can enforce sanctions when players attempt to join or register with the session. See the
				<a href="/docs/game-services/sanctions-interface">Sanctions Interface</a>
				documentation for more information on sanctions.</p>
			<div>
				<p>Sanctioned players may neither join nor register with a session that has sanctions enabled. This includes sanctioned sessions that the player creates themselves; they are still not able to join those sessions if they are a sanctioned player.</p>
			</div>
			<p>Sanctions are enforced through the Sessions Interface. Sanctions enforcement is enabled at session creation based on the value of the
				<code>bSanctionsEnabled</code>
				member in the
				<code>EOS_Sessions_CreateSessionModificationOptions</code>
				structure. If
				<code>bSanctionsEnabled</code>
				is true, then the created session enforces sanctions. See the
				<a href="/docs/en-US#creating-a-session">Creating a Session</a>
				section for more information.</p>
			<p>If a player has a
				<code>RESTRICT_GAME_ACCESS</code>
				sanction, they are automatically kicked from multiplayer sessions in games protected by Anti-Cheat. See the documentation on
				<a href="/docs/game-services/anti-cheat">Anti-cheat</a>
				for more information.</p>
			<p>The
				<a href="/docs/api-ref/functions/eos-sessions-join-session">
					<code>EOS_Sessions_JoinSession</code>
				</a>
				function does not join a player with a
				<code>RESTRICT_MATCHMAKING</code>
				sanction, and it returns the error
				<code>EOS_Sessions_PlayerSanctioned</code>
				on any attempt to do so. However, the function
				<code>EOS_Sessions_RegisterPlayers</code>
				supports multiple players, and, unlike
				<code>EOS_Sessions_JoinSession</code>, it does not return an error when one or more sanctioned players attempts to register with a session that has sanctions enabled. Instead, you must check the response object to ensure that all players are registered. If the session has sanctions enabled, any sanctioned players who failed to register are listed in the
				<code>SanctionedPlayers</code>
				member of the callback result struct
				<code>EOS_Sessions_RegisterPlayersCallbackInfo</code>. See the
				<a href="/docs/en-US#registering-a-player">Registering a Player</a>
				section for more details.</p>
			<div>
				<h2 id="usage-limitations">Usage Limitations</h2>
			</div>
			<p>Users can host, find, and interact with online gaming sessions through the Sessions Interface. A session can be short, like filling a certain number of player slots before starting a game, then disbanding after the game ends. Or it can be longer, like keeping track of a game that cycles through matches on multiple maps or levels. The Sessions Interface also manages game-specific data that supports the back-end service searching and matchmaking functionality.</p>
			<p>For general information about throttling, usage quotas, and best practices, see
				<a href="/docs/epic-online-services/services-overview#service-usage-limitations">Service Usage Limitations</a>.</p>
			<p>The following general limitations apply to sessions:</p>
			<table>
				<thead>
					<tr>
						<th>Feature</th>
						<th>Limitation</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Concurrent players</td>
						<td>1000 per session</td>
					</tr>
					<tr>
						<td>Session attributes</td>
						<td>100 per session</td>
					</tr>
					<tr>
						<td>Attribute name length</td>
						<td>1000 characters</td>
					</tr>
				</tbody>
			</table>
			<p>User interaction with the Sessions Interface must respect the following limitations:</p>
			<table>
				<thead>
					<tr>
						<th>Feature</th>
						<th>Limitation</th>
						<th>Per-Deployment Limitation</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Create a session</td>
						<td>30 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
					<tr>
						<td>Delete a session</td>
						<td>30 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
					<tr>
						<td>Update a session</td>
						<td>30 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
					<tr>
						<td>Add or remove players</td>
						<td>100 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
					<tr>
						<td>Start or stop a session</td>
						<td>30 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
					<tr>
						<td>Invite a user</td>
						<td>100 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
					<tr>
						<td>Filter sessions</td>
						<td>30 requests per minute</td>
						<td>30 request per 1 CCU per minute</td>
					</tr>
				</tbody>
			</table>
			<p>Additionally, there are per-user rate limitations. Consider the following limitations to avoid throttling:</p>
			<table>
				<thead>
					<tr>
						<th>Feature</th>
						<th>User Limit</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Amount of sessions a single user can join at once</td>
						<td>16</td>
					</tr>
				</tbody>
			</table>
			<div>
				<h2 id="matchmaking-security-considerations">Matchmaking Security Considerations</h2>
			</div>
			<p>
				<strong>Matchmaking</strong>
				functionality requires that you take a set of information such as player identifiers or server IP address and broadcast that data to other potential players. Typically session data consists of:</p>
			<ol>
				<li>
					<p>A
						<strong>Host IP Address</strong>, set either using
						<code>EOS_SessionModification_SetHostAddress</code>
						or automatically detected by EOS services. This address is mandatory when attempting to join the game.</p>
				</li>
				<li>
					<p>The
						<strong>EOS Product User ID</strong>
						of all players registered to the session.</p>
				</li>
				<li>
					<p>Any custom attributes that have been added to the session using
						<code>EOS_SessionModification_AddAttribute</code>. These could be anything set by the developer.</p>
				</li>
			</ol>
			<p>Matchmaking takes game data and creates a searchable index, so you should always be conscious of what data is being exposed when creating your sessions. For games with dedicated servers you are exposing the IP address of the server, and for Peer to Peer sessions you could be exposing the IP address of end users.</p>
			<p>
				<strong>Note</strong>: If you have security concerns about exposing the host IP address, you can use
				<code>EOS_SessionModification_SetHostAddress</code>
				to set the host address to something else, such as the P2P socket ID if you use the P2P Interface.</p>
			<p>When you create a session you can specify a
				<strong>permission level</strong>
				for the session using
				<code>EOS_SessionModification_SetPermissionLevel</code>. Sessions have 3 levels of security:</p>
			<table>
				<thead>
					<tr>
						<th>Security Level</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>EOS_OSPF_PublicAdvertised</code>
						</td>
						<td>Any client can get the session in search results without needing to know the session id and can read session information as long as the session is not started or session allows join in progress. Any client/player that has access to the unique session identifier can view session information even if the session is not joinable. Players can also find the session using a registered player's ID, as long as the registered player is in a public session.</td>
					</tr>
					<tr>
						<td>
							<code>EOS_OSPF_JoinViaPresence</code>
						</td>
						<td>Any client/player that has access to the unique session identifier can view session information (typically this information is shared via presence data but can be shared in other ways as well).</td>
					</tr>
					<tr>
						<td>
							<code>EOS_OSPF_InviteOnly</code>
						</td>
						<td>Only players which have been explicitly invited to the session by an existing member of the session can view session information.</td>
					</tr>
				</tbody>
			</table>
			<div>
				<h3 id="best-practices">Best Practices</h3>
			</div>
			<ul>
				<li>
					<p>Make sure your sessions are scoped to the lowest amount of exposure necessary.</p>
				</li>
				<li>
					<p>Don’t add information to session attributes that should not be exposed to everyone that is looking for the session.</p>
				</li>
				<li>
					<p>If you are using JoinViaPresence then make sure to keep the session id hidden from players/UI. If it is exposed then it will allow access to the session data.</p>
				</li>
				<li>
					<p>If your game doesn’t support JoinInProgress, make sure your server starts the session with EOS_Sessions_StartSession to remove the session from future searches while the game is in progress.</p>
				</li>
			</ul>
			<div>
				<h2 id="faq">FAQ</h2>
			</div>
			<p>
				<strong>Q: Why can't I find the server that I just created?</strong>
				<br>
				A: Indexing takes two seconds to refresh, so you might not be able to find your server immediately.</p>
			<p>
				<strong>Q: Why can't I see the same list of servers as my co-worker or friend?</strong>
				<br>
				A: Matchmaking has a two-second delay to ensure that no two people get the same list of servers at the same time. This deliberate jittering avoids race conditions that can affect the efficiency of the servers.</p>
			<p>
				<strong>Q: I want to see the sessions that are set up in my game. How can I see all the sessions in my game?</strong>
				<br>
				A: You can find the list of sessions in your game in the Developer Portal. Sign in to the Developer Portal (at
				<a href="https://dev.epicgames.com/portal/">dev.epicgames.com/portal</a>), and select your product under the
				<strong>Products</strong>
				section in the left sidebar. Go to
				<strong>Game Services</strong>
				&gt;
				<strong>MULTIPLAYER</strong>
				&gt;
				<strong>Matchmaking</strong>.</p>
			<div id="tag_list">
				<a href="/docs/en-US/site-map?tag=Interface">Interface</a>
				<a href="/docs/en-US/site-map?tag=Matchmaking">
					Matchmaking</a>
				<a href="/docs/en-US/site-map?tag=Session">
					Session</a>
			</div>
		</section>
		<aside>
			<div>Contents</div>
			<div>
				<ul>
					<li>
						<a href="#active-sessions">Active Sessions</a>
					</li>
					<li>
						<a href="#session-details">Session Details</a>
					</li>
					<li>
						<a href="#accessing-session-details">Accessing Session Details</a>
					</li>
					<li>
						<a href="#creating-a-session">Creating a Session</a>
					</li>
					<li>
						<a href="#player-details">Player Details</a>
					</li>
					<li>
						<a href="#accessing-the-total-number-of-registered-players">Accessing the Total Number of Registered Players</a>
					</li>
					<li>
						<a href="#accessing-the-product-user-id-of-each-registered-player">Accessing the Product User ID of Each Registered Player</a>
					</li>
					<li>
						<a href="#modifying-a-session">Modifying a Session</a>
					</li>
					<li>
						<a href="#custom-attributes">Custom Attributes</a>
					</li>
					<li>
						<a href="#accessing-an-attribute">Accessing an Attribute</a>
					</li>
					<li>
						<a href="#adding-an-attribute">Adding an Attribute</a>
					</li>
					<li>
						<a href="#removing-an-attribute">Removing an Attribute</a>
					</li>
					<li>
						<a href="#inviting-players-to-a-session">Inviting Players to a Session</a>
					</li>
					<li>
						<a href="#accepting-an-invitation">Accepting an Invitation</a>
					</li>
					<li>
						<a href="#rejecting-an-invitation">Rejecting an Invitation</a>
					</li>
					<li>
						<a href="#discovering-a-remote-session">Discovering a Remote Session</a>
					</li>
					<li>
						<a href="#configuring-a-search">Configuring a Search</a>
					</li>
					<li>
						<a href="#configuring-for-session-id">Configuring for Session ID</a>
					</li>
					<li>
						<a href="#configuring-for-user-id">Configuring for User ID</a>
					</li>
					<li>
						<a href="#configuring-for-attribute-data">Configuring for Attribute Data</a>
					</li>
					<li>
						<a href="#executing-a-search">Executing a Search</a>
					</li>
					<li>
						<a href="#examining-search-results">Examining Search Results</a>
					</li>
					<li>
						<a href="#joining-a-session">Joining a Session</a>
					</li>
					<li>
						<a href="#registering-a-player">Registering a Player</a>
					</li>
					<li>
						<a href="#leaving-a-session">Leaving a Session</a>
					</li>
					<li>
						<a href="#unregistering-a-player">Unregistering a Player</a>
					</li>
					<li>
						<a href="#starting-and-ending-play">Starting and Ending Play</a>
					</li>
					<li>
						<a href="#destroying-a-session">Destroying a Session</a>
					</li>
					<li>
						<a href="#mirroring-session-management-on-remote-clients">Mirroring Session Management on Remote Clients</a>
					</li>
					<li>
						<a href="#enforcing-sanctions">Enforcing Sanctions</a>
					</li>
					<li>
						<a href="#usage-limitations">Usage Limitations</a>
					</li>
					<li>
						<a href="#matchmaking-security-considerations">Matchmaking Security Considerations</a>
					</li>
					<li>
						<a href="#best-practices">Best Practices</a>
					</li>
					<li>
						<a href="#faq">FAQ</a>
					</li>
				</ul>
			</div>
		</aside>
	</section>
	<section></section>
</section>